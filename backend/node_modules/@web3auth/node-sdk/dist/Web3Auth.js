"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Web3Auth = void 0;
const keys_1 = require("@solana/keys");
const signers_1 = require("@solana/signers");
const constants_1 = require("@toruslabs/constants");
const fetch_node_details_1 = require("@toruslabs/fetch-node-details");
const torus_js_1 = require("@toruslabs/torus.js");
const auth_1 = require("@web3auth/auth");
const no_modal_1 = require("@web3auth/no-modal");
const ethers_1 = require("ethers");
const analytics_1 = require("./analytics");
const utils_1 = require("./utils");
class Web3Auth {
    options;
    torusUtils = null;
    nodeDetailManager = null;
    analytics = null;
    projectConfig = null;
    constructor(options) {
        this.validateConstructorOptions(options);
        const network = options.web3AuthNetwork || auth_1.WEB3AUTH_NETWORK.SAPPHIRE_MAINNET;
        this.options = {
            ...options,
            web3AuthNetwork: network,
            useDKG: options.useDKG !== undefined ? options.useDKG : this.getUseDKGDefaultValue(network),
            checkCommitment: typeof options.checkCommitment === "boolean" ? options.checkCommitment : true,
        };
        this.analytics = new analytics_1.SegmentAnalytics();
    }
    get currentChainId() {
        return this.options.defaultChainId || this.options.chains[0].chainId;
    }
    get currentChainNamespace() {
        return this.options.chains?.find((chain) => chain.chainId === this.currentChainId)?.chainNamespace || no_modal_1.CHAIN_NAMESPACES.EIP155;
    }
    get currentChain() {
        return this.options.chains?.find((chain) => chain.chainId === this.currentChainId) || this.options.chains[0];
    }
    async init() {
        const { web3AuthNetwork: network, clientId } = this.options;
        const startTime = Date.now();
        this.analytics.init();
        this.analytics.identify(this.options.clientId, {
            web3auth_client_id: this.options.clientId,
            web3auth_network: this.options.web3AuthNetwork,
        });
        this.analytics.setGlobalProperties({
            sdk_name: analytics_1.SDK_TYPE,
            sdk_version: analytics_1.SDK_VERSION,
            // Required for organization analytics
            web3auth_client_id: this.options.clientId,
            web3auth_network: this.options.web3AuthNetwork,
        });
        // get project config
        let projectConfig;
        try {
            projectConfig = await (0, no_modal_1.fetchProjectConfig)({
                clientId,
                web3AuthNetwork: network,
            });
        }
        catch (e) {
            const error = await (0, auth_1.serializeError)(e);
            no_modal_1.log.error("Failed to fetch project configurations", error);
            throw no_modal_1.WalletInitializationError.notReady("failed to fetch project configurations", error);
        }
        this.projectConfig = projectConfig;
        this.initChainsConfig();
        this.analytics.setGlobalProperties({ team_id: projectConfig.teamId });
        this.torusUtils = new torus_js_1.Torus({
            enableOneKey: true,
            network,
            clientId,
        });
        torus_js_1.Torus.enableLogging(this.options.enableLogging || false);
        this.nodeDetailManager = new fetch_node_details_1.NodeDetailManager({ network, enableLogging: this.options.enableLogging || false });
        this.analytics.track(no_modal_1.ANALYTICS_EVENTS.SDK_INITIALIZATION_COMPLETED, {
            ...this.getInitializationTrackData(),
            duration: Date.now() - startTime,
        });
    }
    async connect(loginParams) {
        if (!this.torusUtils || !this.nodeDetailManager)
            throw no_modal_1.WalletInitializationError.notReady("Please call init first.");
        if (!loginParams.idToken || !loginParams.authConnectionId)
            throw no_modal_1.WalletLoginError.fromCode(5000, "idToken and authConnectionId are required");
        const startTime = Date.now();
        const eventData = {
            auth_connection: auth_1.AUTH_CONNECTION.CUSTOM,
            auth_connection_id: loginParams.authConnectionId,
            group_auth_connection_id: loginParams.groupedAuthConnectionId,
            is_default_auth_connection: false,
            is_user_id_provided: Boolean(loginParams.userId),
            is_user_id_case_sensitive: Boolean(loginParams.isUserIdCaseSensitive),
        };
        try {
            // track connection started event
            this.analytics.track(no_modal_1.ANALYTICS_EVENTS.CONNECTION_STARTED, eventData);
            // get torus key
            const retrieveSharesResponse = await this.getTorusKey(loginParams);
            if (retrieveSharesResponse.metadata.upgraded) {
                throw no_modal_1.WalletLoginError.mfaEnabled();
            }
            const { finalKeyData, oAuthKeyData } = retrieveSharesResponse;
            const privKey = finalKeyData.privKey || oAuthKeyData.privKey;
            if (!privKey)
                throw no_modal_1.WalletLoginError.fromCode(5000, "Unable to get private key from torus nodes");
            let finalPrivKey = privKey.padStart(64, "0");
            if (this.options.usePnPKey) {
                const pnpPrivKey = (0, auth_1.subkey)(finalPrivKey, Buffer.from(this.options.clientId, "base64"));
                finalPrivKey = pnpPrivKey.padStart(64, "0");
            }
            const wallet = await this.getWallet(finalPrivKey);
            this.analytics.track(no_modal_1.ANALYTICS_EVENTS.CONNECTION_COMPLETED, {
                ...eventData,
                ...this.getInitializationTrackData(),
                duration: Date.now() - startTime,
            });
            return wallet;
        }
        catch (err) {
            const error = await (0, auth_1.serializeError)(err);
            this.analytics.track(no_modal_1.ANALYTICS_EVENTS.CONNECTION_FAILED, {
                ...eventData,
                ...(0, no_modal_1.getErrorAnalyticsProperties)(err),
                duration: Date.now() - startTime,
            });
            no_modal_1.log.error("Failed to connect", error);
            throw error;
        }
    }
    getUseDKGDefaultValue(network) {
        // only dkg flow is supported for legacy networks
        if (constants_1.LEGACY_NETWORKS_ROUTE_MAP[network]) {
            return true;
        }
        // for rest networks both flows are supported, but default is non dkg.
        return false;
    }
    validateConstructorOptions(options) {
        // non dkg flow is not supported in legacy networks
        if (options.useDKG === false && constants_1.LEGACY_NETWORKS_ROUTE_MAP[options.web3AuthNetwork]) {
            throw no_modal_1.WalletInitializationError.invalidParams("useDKG cannot be false for legacy networks");
        }
    }
    initChainsConfig() {
        // merge chains from project config with core options, core options chains will take precedence over project config chains
        const chainMap = new Map();
        const allChains = [...(this.projectConfig.chains || []), ...(this.options.chains || [])];
        for (const chain of allChains) {
            const existingChain = chainMap.get(chain.chainId);
            if (!existingChain)
                chainMap.set(chain.chainId, chain);
            else
                chainMap.set(chain.chainId, { ...existingChain, ...chain });
        }
        this.options.chains = Array.from(chainMap.values());
        // validate chains and namespaces
        if (this.options.chains.length === 0) {
            no_modal_1.log.error("chain info not found. Please configure chains on dashboard at https://dashboard.web3auth.io");
            throw no_modal_1.WalletInitializationError.invalidParams("Please configure chains on dashboard at https://dashboard.web3auth.io");
        }
        const validChainNamespaces = new Set(Object.values(no_modal_1.CHAIN_NAMESPACES));
        for (const chain of this.options.chains) {
            if (!chain.chainNamespace || !validChainNamespaces.has(chain.chainNamespace)) {
                no_modal_1.log.error(`Please provide a valid chainNamespace in chains for chain ${chain.chainId}`);
                throw no_modal_1.WalletInitializationError.invalidParams(`Please provide a valid chainNamespace in chains for chain ${chain.chainId}`);
            }
            if (chain.chainNamespace !== no_modal_1.CHAIN_NAMESPACES.OTHER && !(0, no_modal_1.isHexStrict)(chain.chainId)) {
                no_modal_1.log.error(`Please provide a valid chainId in chains for chain ${chain.chainId}`);
                throw no_modal_1.WalletInitializationError.invalidParams(`Please provide a valid chainId as hex string in chains for chain ${chain.chainId}`);
            }
            if (chain.chainNamespace !== no_modal_1.CHAIN_NAMESPACES.OTHER) {
                try {
                    new URL(chain.rpcTarget);
                }
                catch (error) {
                    // TODO: add support for chain.wsTarget
                    no_modal_1.log.error(`Please provide a valid rpcTarget in chains for chain ${chain.chainId}`, error);
                    throw no_modal_1.WalletInitializationError.invalidParams(`Please provide a valid rpcTarget in chains for chain ${chain.chainId}`);
                }
            }
        }
    }
    async getTorusKey(params) {
        const { authConnectionId, idToken, groupedAuthConnectionId } = params;
        const verifier = groupedAuthConnectionId || authConnectionId;
        if (!verifier)
            throw no_modal_1.WalletLoginError.fromCode(5000, "authConnectionId is required");
        const oAuthProviderConfig = this.getOAuthProviderConfig(params);
        const userId = this.getUserId(oAuthProviderConfig, params);
        if (!userId)
            throw no_modal_1.WalletLoginError.fromCode(5000, "userId is required");
        const verifierParams = { verifier_id: userId };
        let aggregateIdToken = "";
        const finalIdToken = idToken;
        if (groupedAuthConnectionId) {
            verifierParams["verify_params"] = [{ verifier_id: userId, idtoken: finalIdToken }];
            verifierParams["sub_verifier_ids"] = [authConnectionId];
            aggregateIdToken = (0, torus_js_1.keccak256)(Buffer.from(finalIdToken, "utf8")).slice(2);
        }
        const { torusNodeEndpoints, torusIndexes, torusNodePub } = await this.nodeDetailManager.getNodeDetails({ verifier, verifierId: userId });
        return this.torusUtils.retrieveShares({
            endpoints: torusNodeEndpoints,
            indexes: torusIndexes,
            verifier,
            verifierParams,
            idToken: aggregateIdToken || finalIdToken,
            nodePubkeys: torusNodePub,
            useDkg: this.options.useDKG,
            checkCommitment: this.options.checkCommitment,
        });
    }
    getOAuthProviderConfig(loginParams) {
        const { authConnectionId, groupedAuthConnectionId } = loginParams;
        const authConnection = auth_1.AUTH_CONNECTION.CUSTOM;
        const providerConfig = this.projectConfig.embeddedWalletAuth.find((x) => {
            if (groupedAuthConnectionId && authConnectionId) {
                return (x.authConnection === authConnection && x.groupedAuthConnectionId === groupedAuthConnectionId && x.authConnectionId === authConnectionId);
            }
            if (authConnectionId) {
                return x.authConnection === authConnection && x.authConnectionId === authConnectionId;
            }
            // return the default auth connection, if not found, return undefined
            return x.authConnection === authConnection && x.isDefault;
        });
        if (!providerConfig) {
            return {
                authConnection,
                authConnectionId,
                groupedAuthConnectionId,
                jwtParameters: {
                    userIdField: "sub",
                    isUserIdCaseSensitive: true,
                },
            };
        }
        return providerConfig;
    }
    getUserId(oAuthProviderConfig, loginParams) {
        const { userId, idToken, isUserIdCaseSensitive, userIdField } = loginParams;
        if (userId)
            return userId;
        const { userIdField: oAuthProviderConfigUserIdField, isUserIdCaseSensitive: oAuthProviderConfigIsUserIdCaseSensitive } = oAuthProviderConfig.jwtParameters;
        if (idToken) {
            const { payload } = (0, utils_1.parseToken)(idToken) || {};
            if (!payload)
                throw no_modal_1.WalletLoginError.fromCode(5000, "Invalid idToken");
            return (0, auth_1.getUserId)(payload, auth_1.AUTH_CONNECTION.CUSTOM, userIdField || oAuthProviderConfigUserIdField, isUserIdCaseSensitive || oAuthProviderConfigIsUserIdCaseSensitive);
        }
        throw no_modal_1.WalletLoginError.fromCode(5000, "userId or idToken is required");
    }
    async getWallet(privateKey) {
        const provider = new no_modal_1.CommonPrivateKeyProvider({
            config: {
                keyExportEnabled: this.projectConfig.enableKeyExport,
                chain: this.currentChain,
                chains: this.options.chains,
            },
        });
        await provider.setupProvider(privateKey);
        if (this.currentChainNamespace === no_modal_1.CHAIN_NAMESPACES.SOLANA) {
            const ed25519Key = (0, auth_1.getED25519Key)(privateKey).sk;
            const keyPair = await (0, keys_1.createKeyPairFromBytes)(new Uint8Array(ed25519Key));
            const signer = await (0, signers_1.createSignerFromKeyPair)(keyPair);
            return { chainNamespace: no_modal_1.CHAIN_NAMESPACES.SOLANA, provider, signer: signer };
        }
        else if (this.currentChainNamespace === no_modal_1.CHAIN_NAMESPACES.EIP155) {
            const ethersWallet = new ethers_1.Wallet(privateKey);
            const signer = ethersWallet.connect(new ethers_1.JsonRpcProvider(this.currentChain.rpcTarget));
            return { chainNamespace: no_modal_1.CHAIN_NAMESPACES.EIP155, provider, signer: signer };
        }
        else {
            return { chainNamespace: no_modal_1.CHAIN_NAMESPACES.OTHER, provider, signer: null };
        }
    }
    getInitializationTrackData() {
        try {
            const defaultChain = this.options.chains?.find((chain) => chain.chainId === this.options.defaultChainId);
            const rpcHostnames = Array.from(new Set(this.options.chains?.map((chain) => (0, no_modal_1.getHostname)(chain.rpcTarget)))).filter(Boolean);
            return {
                chain_ids: this.options.chains?.map((chain) => (0, no_modal_1.getCaipChainId)(chain)),
                chain_names: this.options.chains?.map((chain) => chain.displayName),
                chain_rpc_targets: rpcHostnames,
                default_chain_id: defaultChain ? (0, no_modal_1.getCaipChainId)(defaultChain) : undefined,
                default_chain_name: defaultChain?.displayName,
                logging_enabled: this.options.enableLogging,
                sfa_key_enabled: !this.options.usePnPKey,
                use_dkg: this.options.useDKG,
                check_commitment: this.options.checkCommitment,
            };
        }
        catch (error) {
            no_modal_1.log.error("Failed to get initialization track data", error);
            return {};
        }
    }
}
exports.Web3Auth = Web3Auth;
//# sourceMappingURL=Web3Auth.js.map